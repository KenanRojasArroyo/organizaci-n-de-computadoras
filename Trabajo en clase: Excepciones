section .data
err_code dd 0 ; 0 = ok, 1 = divisi√≥n por cero

section .text
global _start

_start:
mov eax, 10
mov ebx, 0 ; divisor

cmp ebx, 0
je .throw_div_zero ; si divisor es 0
jmp .try_end ; si divisor no es 0

.throw_div_zero:
mov dword [err_code], 1 ; guardamos 1 porque salio mal
jmp .catch

.try_end:
mov dword [err_code], 0 ; guardamos 0 porque salio bien
jmp .after_catch

.catch:
mov eax, [err_code] ; se carga el codigo del error 0 o 1
cmp eax, 1
je .handle_div_zero ; si es 1
jmp .after_catch

.handle_div_zero:
jmp .after_catch

; salida del programa
.after_catch:
mov rax, 60 ; exit
xor rdi, rdi
syscall
